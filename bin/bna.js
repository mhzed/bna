// Generated by CoffeeScript 1.10.0
(function() {
  var _, argv, bna, callFuseThrottleSec, copied, ddir, deps, dofuse, dstfile, fpath, fs, isDir, k, log, mfile, optimist, path, resolver, targetPath, v;

  optimist = require('optimist').usage('Build modules and dependencies for app in the current dir.\nUsage: bna .').boolean(['p', 'c', 'q', 'w', 'l', 'v', 'jsx', 'm']).alias('p', 'packagejson').alias('c', 'copy').alias('f', 'fuse').alias('q', 'quiet').alias('l', 'line').alias('v', 'version').alias('m', 'map').string("fuselib").string('f').string("o").describe("v", "print version").describe('p', 'write module dependencies to package.json').describe('c', 'copy depended external modules to local node_modules dir').describe('f', 'generate a single executable js file, see doc.').describe('m', 'generate source map for fuse option').describe('jsx', 'enable react jsx file support').describe('fuselib', 'fuse to a file that exports all dependant modules.').describe("o", 'specify output file or dir for fuse. Optional, default is .').describe("q", 'quite mode. No warnings').describe('w', 'watch file: fuse on change').describe('l', 'print warnings with line number');

  argv = optimist.argv;

  bna = require("../lib/bna");

  fs = require("fs");

  path = require("path");

  _ = require("underscore");

  log = require('lawg');

  if (argv.v) {
    console.log(require("../package.json").version);
    return;
  }

  if (argv.quiet) {
    bna.quiet = true;
  }

  if (argv.line) {
    bna.locations = true;
  }

  if (argv.jsx) {
    bna.enableJsx();
  }

  if (!(argv.p || argv.c || argv.f || argv.fuselib)) {
    targetPath = argv._[0];
    if (!targetPath) {
      console.log(optimist.help());
      return;
    } else {
      targetPath = path.resolve(targetPath);
    }
    if (targetPath && fs.existsSync(targetPath)) {
      if (fs.lstatSync(targetPath).isDirectory()) {
        console.log("Analyzing directory...");
        bna.dir.npmDependencies(targetPath, function(err, deps, externDeps, unit, warnings) {
          var edeps, extdep, j, k, l, len, len1, more, mpath, name, npad, pad, ref, ref1, require, results, sortedDeps, unresolved, v, version, w;
          if (err) {
            return console.log(err);
          } else {
            unresolved = _.uniq((function() {
              var j, len, results;
              results = [];
              for (j = 0, len = warnings.length; j < len; j++) {
                w = warnings[j];
                if (w.reason === 'resolve') {
                  results.push(w.node["arguments"][0].value);
                }
              }
              return results;
            })());
            if (unresolved.length > 0) {
              console.log("Unresolved requires:");
              console.log(unresolved);
            }
            console.log("Resolved module dependencies are:");
            edeps = {};
            if (externDeps) {
              for (j = 0, len = externDeps.length; j < len; j++) {
                ref = externDeps[j], require = ref.require, mpath = ref.mpath, version = ref.version;
                edeps[require + "@" + version] = mpath;
              }
            }
            pad = (function(_this) {
              return function(str, n) {
                var i, l, ref1;
                if (n > str.length) {
                  for (i = l = 0, ref1 = n - str.length; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
                    str += ' ';
                  }
                }
                return str;
              };
            })(this);
            npad = 0;
            for (k in deps) {
              v = deps[k];
              if (v !== null) {
                if ((k.length + v.length + 2) > npad) {
                  npad = k.length + v.length + 2;
                }
              }
            }
            sortedDeps = {};
            ref1 = _.keys(deps).sort();
            for (l = 0, len1 = ref1.length; l < len1; l++) {
              k = ref1[l];
              sortedDeps[k] = deps[k];
            }
            deps = sortedDeps;
            results = [];
            for (k in deps) {
              v = deps[k];
              if (v === null) {
                if (!/[\/\\]/.test(k)) {
                  results.push(console.log("  " + k));
                } else {
                  results.push(void 0);
                }
              } else {
                name = k + "@" + v;
                extdep = edeps[name];
                more = extdep ? "(" + extdep + ")" : "";
                results.push(console.log("  " + (pad(name, npad)) + more));
              }
            }
            return results;
          }
        });
      } else {
        console.log("Analyzing file...");
        deps = (function() {
          var ref, results;
          ref = bna.fileDep(targetPath)[0];
          results = [];
          for (k in ref) {
            v = ref[k];
            results.push(k + "@" + v);
          }
          return results;
        })();
        console.log("Dependencies are:");
        console.log(deps.sort());
      }
    }
  } else if (argv.p) {
    bna.writePackageJson(process.cwd(), function(err, removedPackages) {
      if (err) {
        return console.log(err.stack);
      } else {
        if (removedPackages.length) {
          console.log("Removed unused packages: " + removedPackages);
        }
        return console.log("package.json dependencies updated");
      }
    });
  } else if (argv.c) {
    copied = false;
    bna.copyExternDependModules(process.cwd(), function(msg) {
      console.log(msg);
      return copied = true;
    }, function(err) {
      if (err) {
        return console.log(err.stack);
      } else {
        return console.log(copied ? "copying finished" : "nothing to copy");
      }
    });
  } else if (argv.f || argv.fuselib) {
    resolver = require("resolve");
    ddir = ".";
    if (argv.f === true || argv.fuselib === true) {
      fpath = path.resolve(".");
    } else {
      fpath = path.resolve(argv.f || argv.fuselib);
    }
    if (fs.statSync(fpath).isDirectory()) {
      mfile = bna.mainFile(fpath);
      if ((argv.fuselib != null) && !mfile) {

      } else {
        fpath = mfile;
      }
    }
    if (!fpath) {
      console.log("Nothing to fuse, are you in a project folder with package.json?");
      process.exit(1);
    }
    console.log("Fusing file " + (path.relative('.', fpath)));
    if (argv.o) {
      dstfile = null;
      ddir = path.resolve(argv.o);
      if (path.extname(ddir).toLowerCase() === ".js") {
        dstfile = path.basename(ddir);
        ddir = path.dirname(ddir);
      }
    }
    isDir = fs.statSync(fpath).isDirectory();
    dofuse = (function(_this) {
      return function(cb) {
        if (isDir) {
          return bna.fuseDirTo(fpath, ddir, {
            aslib: argv.fuselib != null,
            dstfile: dstfile,
            generateSm: argv.m
          }, cb);
        } else {
          return process.nextTick(function() {
            var units;
            units = bna.fuseTo(fpath, ddir, {
              aslib: argv.fuselib != null,
              dstfile: dstfile,
              generateSm: argv.m
            });
            if (cb) {
              return cb(units);
            }
          });
        }
      };
    })(this);
    if (argv.w) {
      callFuseThrottleSec = typeof argv.w === 'string' ? parseInt(argv.w) : 2;
      (function(_this) {
        return (function() {
          var onChange, watch;
          onChange = (function() {
            var doChange;
            doChange = _.throttle(function() {
              return dofuse(function(units) {
                return watch(units);
              });
            }, callFuseThrottleSec * 1000, {
              leading: true
            });
            return function(e, fp) {
              console.log((path.relative('.', fp)) + " changed");
              return doChange();
            };
          })();
          watch = (function() {
            var watchers;
            watchers = {};
            return function(units) {
              var fp, j, len, newWatchers, unit, watcher;
              newWatchers = {};
              for (j = 0, len = units.length; j < len; j++) {
                unit = units[j];
                if (!unit.isCore) {
                  if (unit.fpath in watchers) {
                    newWatchers[unit.fpath] = watchers[unit.fpath];
                    delete watchers[unit.fpath];
                  } else {
                    (function(unit) {
                      if (!argv.quiet) {
                        console.log("Begin watching " + (path.relative('.', unit.fpath)));
                      }
                      return newWatchers[unit.fpath] = fs.watchFile(unit.fpath, function(e) {
                        return onChange(e, unit.fpath);
                      });
                    })(unit);
                  }
                }
              }
              for (fp in watchers) {
                watcher = watchers[fp];
                if (!argv.quiet) {
                  console.log("Stop watching  " + (path.relative('.', fp)));
                }
                fs.unwatchFile(fp);
              }
              return watchers = newWatchers;
            };
          })();
          return dofuse(watch);
        });
      })(this)();
    } else {
      dofuse();
    }
  }

}).call(this);

//# sourceMappingURL=bna.js.map
