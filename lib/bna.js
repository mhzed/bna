// Generated by CoffeeScript 1.6.3
(function() {
  var ast, async, bna, esprima, fs, path, resolver, wrench, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require("fs");

  resolver = require("resolve");

  async = require("async");

  path = require("path");

  _ = require("under_score");

  esprima = require('esprima');

  ast = require("./ast");

  wrench = require("wrench");

  module.exports = bna = {
    _cache: {},
    /*
     * given path to js file (as returned by require.resolve), identify the node module that contains it, think of it
     * as reverse of require.resolve
     * returns
     *
     * @param file  : path to js file to identify
     * @returns  {
     *    "require": "mylib"
     *     "path"   : "node_modules/mylib/file.js",
     *     "mpath"  : "node_modules/mylib",
     *     "package" : { package.json object if exists }
     *   }
     *   - "mpath" may point to a file in case of node_modules/mylib.js
    */

    identify: function(file) {
      var packageJsonFile, ret;
      ret = {
        "path": file,
        isSysModule: function() {
          return this.path === this.require;
        }
      };
      ret.mpath = /\/|\\/.test(file) ? bna.findModulePath(file) : file;
      if (ret.mpath === file) {
        ret.require = path.basename(ret.mpath).replace(/\.(js|node)$/i, '');
      } else {
        ret.require = path.basename(ret.mpath);
        packageJsonFile = path.join(ret.mpath, "package.json");
        if (fs.existsSync(packageJsonFile)) {
          ret["package"] = JSON.parse(fs.readFileSync(packageJsonFile));
        }
      }
      return ret;
    },
    findModulePath: function(fullpath) {
      var packageJsonFile, parentpath;
      if (!fullpath || fullpath === "/") {
        return void 0;
      }
      if (fs.existsSync(path.join(fullpath, "package.json"))) {
        return fullpath;
      }
      parentpath = path.dirname(fullpath);
      packageJsonFile = path.join(parentpath, "package.json");
      if (fs.existsSync(packageJsonFile)) {
        return parentpath;
      } else if (path.basename(parentpath) === "node_modules") {
        return fullpath;
      } else if (['index.js', 'index.node'].indexOf(path.basename(fullpath).toLowerCase()) !== -1) {
        return parentpath;
      } else {
        return bna.findModulePath(parentpath);
      }
    },
    mainFile: function(mpath) {
      fpath;
      var fpath, pkg;
      if (fs.existsSync(fpath = path.join(mpath, "package.json"))) {
        pkg = JSON.parse(fs.readFileSync(fpath));
        if ("main" in pkg) {
          return path.resolve(mpath, pkg.main);
        }
      } else if (fs.existsSync(fpath = path.join(mpath, "index.js"))) {
        return fpath;
      } else if (fs.existsSync(fpath = path.join(mpath, "index.node"))) {
        return fpath;
      }
      return null;
    },
    /*
     * async resolve all dependencies of file,
     * because nodejs supports circular require, returned data may contain circular reference, so when you recursively
     * walk the tree, make sure you handle the circular reference, see "_collapsePackages" for example.
     *
     * @param file          : path to the js file
     * @param level         : recursively resolve up to this many levels, optional, default infinite
     * @param cb(err, detail) : where obj is what's returned by identify, with addition of 'deps' member
     *                        detail.deps   :  what this file depends on, as an array of more 'identify' details
    */

    resolve: function(file, level, cb) {
      var detail;
      if (_(level).isFunction()) {
        cb = level;
        level = -1;
      }
      detail = bna.identify(file);
      bna._cache[file] = detail;
      if (level === 0 || detail.isSysModule()) {
        cb(null, detail);
        return;
      }
      return async.waterfall([
        function(cb) {
          var allrequires, expr, expressions, loc, name, requires, _i, _len, _ref;
          allrequires = bna.findRequire(file);
          if (allrequires.expressions.length > 0) {
            expressions = bna.findRequire(file, {
              loc: true
            }).expressions;
            for (_i = 0, _len = expressions.length; _i < _len; _i++) {
              _ref = expressions[_i], expr = _ref[0], loc = _ref[1];
              console.log("Warning: ignored require expression at " + loc.file + ":" + loc.start.line);
            }
          }
          requires = (function() {
            var _j, _len1, _ref1, _ref2, _results;
            _ref1 = allrequires.strings;
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              _ref2 = _ref1[_j], name = _ref2[0], loc = _ref2[1];
              _results.push(name);
            }
            return _results;
          })();
          return async.map(requires, function(require_item, cb) {
            return resolver(require_item, {
              extensions: [".js", ".node"],
              basedir: path.dirname(path.resolve(file))
            }, function(err, resolved) {
              if (err) {
                return cb(null, null);
              } else {
                return cb(null, resolved);
              }
            });
          }, function(err, resolved_items) {
            resolved_items = _.compact(resolved_items);
            return cb(err, resolved_items);
          });
        }, function(depend_files, cb) {
          return async.map(depend_files, function(resolved_file, cb) {
            if (resolved_file in bna._cache) {
              return cb(null, bna._cache[resolved_file]);
            } else {
              return bna.resolve(resolved_file, level - 1, cb);
            }
          }, function(err, details) {
            detail.deps = details;
            return cb(err, detail);
          });
        }
      ], cb);
    },
    /*
        Internal, collapse dependent files belong to same package
        parameter is not modified
    */

    _collapsePackages: function(paramDetail) {
      var doCollapse, memory;
      memory = {};
      doCollapse = function(paramDetail) {
        var deps, detail;
        memory[paramDetail.mpath] = true;
        detail = _({}).extend(paramDetail);
        if (!detail.deps) {
          return detail;
        }
        deps = _(detail.deps).reduce(function(memo, dep) {
          if (detail.mpath === dep.mpath) {
            if (dep.deps !== void 0) {
              _(memo).append(dep.deps);
            }
          } else {
            memo.push(dep);
          }
          return memo;
        }, []);
        detail.deps = _(deps).chain().map(function(dep) {
          if (memory[dep.mpath]) {
            return dep;
          } else {
            return doCollapse(dep);
          }
        }).unique(function(dep) {
          return dep.mpath;
        }).value();
        return detail;
      };
      return doCollapse(paramDetail);
    },
    /*
     * figures out module dependencies for you,
     *  how does it work?  by finding the main file for a package, then walk through ast of the file, find all requires
     *  to determine the external&local packages in its dependencies.
     *   * external : a required external and non-system node module
     *   * local    : the module exists locally (can be resolved via require.resolve)
     *
     * @param fpath          : path of main module file, should be what's returned by require.resolve('module')
     * @param cb(err, dependencies), dependencies is what npm expects in package.json
    */

    npmDependencies: function(fpath, cb) {
      return bna.resolve(require.resolve(fpath), function(err, detail) {
        var dependencies;
        if (err) {
          return cb(err);
        }
        detail = bna._collapsePackages(detail);
        dependencies = null;
        if (!err) {
          dependencies = _(detail.deps).reduce(function(memo, depDetail) {
            if (depDetail["package"]) {
              memo[depDetail.require] = depDetail["package"].version;
            } else if (!depDetail.isSysModule()) {
              memo[depDetail.require] = null;
            }
            return memo;
          }, {});
        }
        return cb(err, dependencies);
      });
    },
    /*
     *  Give a module, find all its dependencies that are NOT located in its local node_module path, useful
     *  for building the final app
     *
     * @param file     : path of main module file, should be what's returned by require.resolve('module')
     * @param cb (err, dependencies), where dependencies is an array of following object:
     *          {
     *              "require"   : require_name,
     *              "mpath"     : path to module,
     *              "version"   : version of module in package.json
     *          }
     *          * the first element in dependencies point to the module containing parameter file
    */

    externDependModules: function(file, cb) {
      return bna.resolve(file, function(err, detail) {
        var isPathContained, memory, ret, walk;
        if (err) {
          return cb(err);
        }
        detail = bna._collapsePackages(detail);
        ret = [detail];
        isPathContained = function(path) {
          var e, i, _i, _len;
          for (i = _i = 0, _len = ret.length; _i < _len; i = ++_i) {
            e = ret[i];
            if (path.indexOf(e.mpath) === 0) {
              return true;
            }
          }
          return false;
        };
        memory = {};
        walk = function(detail) {
          memory[detail.mpath] = true;
          if (!detail.isSysModule() && !isPathContained(detail.mpath)) {
            ret.push(detail);
          }
          if (detail.deps) {
            return detail.deps.forEach(function(dep) {
              if (!memory[dep.mpath]) {
                return walk(dep);
              }
            });
          }
        };
        walk(detail);
        ret = _(ret).chain().map(function(detail) {
          return {
            'require': detail.require,
            'mpath': detail.mpath,
            'version': detail["package"] ? detail["package"].version : null
          };
        }).unique(function(detail) {
          return detail.mpath;
        }).value();
        return cb(err, ret);
      });
    },
    dir: {
      _scanDir: function(dir, iteratorCb, doneCb) {
        return async.waterfall([
          function(cb) {
            var files, fnpm;
            files = [];
            fnpm = require("fstream-npm");
            return fnpm({
              path: dir
            }).on("child", function(c) {
              return files.push(c._path);
            }).on('close', function() {
              return cb(null, files);
            });
          }, function(files, cb) {
            return async.each(files, function(file, cb) {
              return fs.stat(file, function(err, stat) {
                if (stat.isDirectory() && path.basename(file) !== 'node_modules') {
                  return iteratorCb(file, true, cb);
                } else if (path.extname(file) === ".js") {
                  return iteratorCb(file, false, cb);
                } else {
                  return cb();
                }
              });
            }, cb);
          }
        ], doneCb);
      },
      npmDependencies: function(dir, cb) {
        var alldeps;
        alldeps = {};
        return bna.dir._scanDir(dir, function(file, isDir, cb) {
          var f;
          f = isDir ? bna.dir.npmDependencies : bna.npmDependencies;
          return f(file, function(err, deps) {
            _(alldeps).extend(deps);
            return cb(err);
          });
        }, function(err) {
          var detail;
          detail = bna.identify(dir);
          delete alldeps[detail.require];
          return cb(err, alldeps);
        });
      },
      externDependModules: function(dir, cb) {
        var alldeps;
        alldeps = [];
        return bna.dir._scanDir(dir, function(file, isDir, cb) {
          var f;
          f = isDir ? bna.dir.externDependModules : bna.externDependModules;
          return f(file, function(err, deps) {
            _(alldeps).append(deps);
            return cb(err);
          });
        }, function(err) {
          var deps;
          deps = _(alldeps).chain().unique(function(d) {
            return d.mpath;
          }).filter(function(d) {
            return d.mpath.indexOf(dir) !== 0;
          }).value();
          deps = _([alldeps[0]]).append(deps);
          return cb(err, deps);
        });
      }
    },
    /*
     * Make extern dependencies local by copying them to local node_modules folder
     * @param mpath     path to a dir or file (the file must be main entry point of module, i.e. returned by require.resolve
     * @param progressCb (msg),  copy in progress callback, if you want to print status
     * @param doneCb(err) completion callback
     *
    */

    copyExternDependModules: function(mpath, progressCb, doneCb) {
      return fs.stat(mpath, function(err, stat) {
        var f;
        if (err) {
          return cb(err);
        }
        f = stat.isDirectory() ? bna.dir.externDependModules : bna.externDependModules;
        return f(mpath, function(err, dependencies) {
          var targetPath;
          targetPath = path.join(dependencies[0].mpath, "node_modules");
          if (!fs.existsSync(targetPath)) {
            wrench.mkdirSyncRecursive(targetPath);
          }
          return async.eachSeries(dependencies.slice(1), function(d, cb) {
            var targetModulePath;
            targetModulePath = path.join(targetPath, path.basename(d.mpath));
            progressCb(_("Copying '%s': %s => %s").format(d.require, path.relative(process.cwd(), d.mpath), path.relative(process.cwd(), targetModulePath)));
            if (!fs.existsSync(targetModulePath)) {
              fs.mkdirSync(targetModulePath);
            }
            return wrench.copyDirRecursive(d.mpath, targetModulePath, cb);
          }, doneCb);
        });
      });
    },
    /*
     * Merge the module dependency calculated by bna.npmDependencies or bna.dir.npmDependencies into the package.json
     * of main module. The merge rules are:
     * 1. if not exist yet, dependency is added
     * 2. otherwise, do not modify current package.json
          a. however if detected dependency exits in current pakcage.json, then check if versions are compatible,
     *
     * @param mpath     path to a dir or file (the file must be main entry point of module, i.e. returned by require.resolve
     * @param cb(err, [] )  [] is removed packages
    */

    writePackageJson: function(mpath, cb) {
      var semver;
      semver = require("semver");
      return fs.stat(mpath, function(err, stat) {
        var f;
        if (err) {
          return cb(err);
        }
        f = stat.isDirectory() ? bna.dir.npmDependencies : bna.npmDependencies;
        return f(mpath, function(err, deps) {
          var errList, newdep, oldDep, pkgJson, pkgJsonFile;
          if (err) {
            return cb(err);
          }
          if (stat.isFile()) {
            mpath = bna.identify(mpath).mpath;
          }
          pkgJsonFile = path.join(mpath, "package.json");
          pkgJson = {};
          if (fs.existsSync(pkgJsonFile)) {
            pkgJson = JSON.parse(fs.readFileSync(pkgJsonFile, "utf8"));
          }
          oldDep = pkgJson.dependencies || {};
          newdep = {};
          errList = [];
          _(deps).each(function(version, name) {
            var oldVer;
            if (version === null) {
              return errList.push(_("%s is not versioned!").format(name));
            } else if (!(name in oldDep)) {
              return newdep[name] = version;
            } else {
              oldVer = oldDep[name];
              if (!semver.satisfies(version, oldVer)) {
                return errList.push(_("%s: %s does not satisfy %s").format(name, version, oldVer));
              } else {
                delete oldDep[name];
                return newdep[name] = oldVer;
              }
            }
          });
          if (errList.length > 0) {
            return cb(new Error(errList.join("\n")));
          } else {
            pkgJson.dependencies = newdep;
            return fs.writeFile(pkgJsonFile, JSON.stringify(pkgJson, null, 2), "utf8", function(err) {
              return cb(err, _(oldDep).keys());
            });
          }
        });
      });
    },
    /*
      Given js sourcecode, find require, returns
      { strings: [ ['name', location], ...]
        expressions : [['expr', location], ...]
      }
      * location is only set if opt.loc is true
      opt: { loc : true/false }
    */

    findRequire: function(filepath, opt) {
      var modules, src;
      if (opt == null) {
        opt = {};
      }
      src = fs.readFileSync(filepath).toString();
      if (typeof src !== 'string') {
        src = String(src);
      }
      src = src.replace(/^#![^\n]*\n/, '');
      modules = {
        strings: [],
        expressions: []
      };
      if (src.indexOf('require') === -1) {
        return modules;
      }
      ast.traverse(esprima.parse(src, opt), function(node) {
        if (ast.isRequire(node)) {
          if (opt.loc) {
            node.loc.file = filepath;
            if (node["arguments"].length && node["arguments"][0].type === 'Literal') {
              return modules.strings.push([node["arguments"][0].value, node.loc]);
            } else {
              return modules.expressions.push([node["arguments"][0], node.loc]);
            }
          } else {
            if (node["arguments"].length && node["arguments"][0].type === 'Literal') {
              return modules.strings.push([node["arguments"][0].value]);
            } else {
              return modules.expressions.push([node["arguments"][0]]);
            }
          }
        }
      });
      return modules;
    },
    fuse: function(filepath, opts) {
      var getreqs, ret, unit, units, warnings;
      if (opts == null) {
        opts = {};
      }
      filepath = path.resolve(filepath);
      unit = bna._parseFile(filepath, {}, opts.fakeCode);
      getreqs = function(unit, cache) {
        var child_unit, node, units;
        if (unit.fpath in cache) {
          return cache[unit.fpath];
        }
        cache[unit.fpath] = units = [];
        _(units).append(_((function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = unit.requires;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], node = _ref1.node, child_unit = _ref1.unit;
            _results.push(getreqs(child_unit, cache));
          }
          return _results;
        })()).flatten());
        units.push(unit);
        return units;
      };
      units = _(getreqs(unit, {})).unique(function(unit) {
        return unit.fpath;
      });
      warnings = _((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = units.length; _i < _len; _i++) {
          unit = units[_i];
          _results.push(unit.warnings);
        }
        return _results;
      })()).flatten();
      ret = (require("./fuse")).generate(units, opts.aslib);
      ret.push(warnings);
      return ret;
    },
    prettyWarnings: function(warnings) {
      var msgs, node, reason, _i, _len, _ref, _results;
      msgs = {
        'nonconst': 'require ignored because parameter is not a constant string',
        'resolve': 'require ignored because parameter can not be resolved'
      };
      _results = [];
      for (_i = 0, _len = warnings.length; _i < _len; _i++) {
        _ref = warnings[_i], node = _ref.node, reason = _ref.reason;
        _results.push("" + (path.relative('.', node.loc.fpath)) + ":" + node.loc.start.line + ": " + msgs[reason]);
      }
      return _results;
    },
    fuseTo: function(filepath, dstdir, opts) {
      var binaryunits, bunit, content, dfile, dstfile, warning, warnings, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (opts == null) {
        opts = {};
      }
      filepath = path.resolve(filepath);
      _ref = bna.fuse(filepath, opts), content = _ref[0], binaryunits = _ref[1], warnings = _ref[2];
      _ref1 = bna.prettyWarnings(warnings);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        warning = _ref1[_i];
        console.log(warning);
      }
      wrench.mkdirSyncRecursive(dstdir);
      dstfile = opts.dstfile || path.resolve(dstdir, path.basename(filepath, ".js") + ".fused.js");
      if (opts.verbose) {
        console.log("Generating " + (path.relative('.', dstfile)));
      }
      fs.writeFileSync(dstfile, content);
      _results = [];
      for (_j = 0, _len1 = binaryunits.length; _j < _len1; _j++) {
        bunit = binaryunits[_j];
        dfile = path.resolve(dstdir, bunit.key);
        if (fs.existsSync(dfile)) {
          _results.push(console.log("Skipped copying " + dfile + ", already exists."));
        } else {
          if (opts.verbose) {
            console.log("Copying to " + dfile);
          }
          wrench.mkdirSyncRecursive(path.dirname(dfile));
          _results.push(fs.createReadStream(bunit.fpath).pipe(fs.createWriteStream(dfile)));
        }
      }
      return _results;
    },
    fuseDirTo: function(dirpath, dstdir, opts, cb) {
      var fakeCode, scandir;
      fakeCode = "";
      scandir = function(curdir, cb) {
        var files, fnpm;
        files = [];
        fnpm = require("fstream-npm");
        return fnpm({
          path: curdir
        }).on("child", function(c) {
          return files.push(c._path);
        }).on('close', function() {
          var extname, fpath, mpath, name, pkg, recursePaths, stat, _i, _len;
          recursePaths = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            name = files[_i];
            fpath = path.resolve(curdir, name);
            stat = fs.statSync(fpath);
            if (stat.isFile()) {
              extname = path.extname(name).toLowerCase();
              if (name.toLowerCase() === "package.json") {
                pkg = JSON.parse(fs.readFileSync(fpath));
                if (pkg.main) {
                  mpath = path.resolve(path.dirname(fpath), pkg.main);
                  fakeCode += "require('./" + (path.relative(dirpath, mpath)) + "')\n";
                }
              } else if (extname === ".js" || extname === ".node") {
                fakeCode += "require('./" + (path.relative(dirpath, fpath)) + "')\n";
              }
            } else if (stat.isDirectory()) {
              if (fs.existsSync(path.resolve(fpath, "package.json")) || fs.existsSync(path.resolve(fpath, "index.js")) || fs.existsSync(path.resolve(fpath, "index.node"))) {
                fakeCode += "require('./" + (path.relative(dirpath, fpath)) + "')\n";
              } else {
                recursePaths.push(fpath);
              }
            }
          }
          return async.eachSeries(recursePaths, function(path, cb) {
            return scandir(fpath, cb);
          }, cb);
        });
      };
      return scandir(dirpath, function() {
        if (!fakeCode) {
          console.log("No files detected");
        } else {
          opts.fakeCode = fakeCode;
          bna.fuseTo(path.resolve(dirpath, "lib.js"), dstdir, opts);
        }
        if (cb) {
          return cb();
        }
      });
    },
    _parseFile: function(filepath, cache, overrideContent) {
      var bad_require_detected, code, e, isBinary, isCore, unit;
      if (filepath in cache) {
        return cache[filepath];
      }
      isCore = !/[\\\/]/.test(filepath);
      isBinary = /\.node$/i.test(filepath);
      unit = {
        isCore: isCore,
        isBinary: isBinary,
        fpath: filepath,
        src: "",
        requires: [],
        warnings: [],
        "package": void 0
      };
      cache[filepath] = unit;
      if (isCore || isBinary) {
        return unit;
      }
      if (overrideContent) {
        unit.src = overrideContent;
      } else {
        unit.src = fs.readFileSync(filepath).toString().replace(/^#![^\n]*\n/, '');
      }
      if (path.extname(filepath).toLowerCase() === ".json") {
        return unit;
      }
      (function() {
        var detail, mainfiles, _ref;
        detail = bna.identify(filepath);
        mainfiles = [path.join(detail.mpath, "index.js"), path.join(detail.mpath, "index.node")];
        if (detail["package"]) {
          detail["package"].name = detail.require;
          if (detail["package"].main) {
            mainfiles.push(path.resolve(detail.mpath, detail["package"].main));
          }
        }
        if (_ref = unit.fpath, __indexOf.call(mainfiles, _ref) >= 0) {
          return unit["package"] = detail["package"] || {
            name: detail.require,
            version: 'x'
          };
        }
      })();
      bad_require_detected = false;
      try {
        code = esprima.parse(unit.src, {
          loc: false
        });
      } catch (_error) {
        e = _error;
        throw new Error("While parsing " + filepath + ": " + e);
      }
      ast.traverse(code, [ast.isRequire], function(node) {
        var arg, fullpath, modulename, runit;
        arg = node["arguments"][0];
        if (arg && arg.type === 'Literal') {
          modulename = arg.value;
          try {
            fullpath = resolver.sync(modulename, {
              extensions: ['.js', '.node'],
              basedir: path.dirname(filepath)
            });
          } catch (_error) {
            e = _error;
            bad_require_detected = true;
          }
          if (!e) {
            runit = bna._parseFile(fullpath, cache);
            return unit.requires.push({
              node: node,
              unit: runit
            });
          }
        } else {
          return bad_require_detected = true;
        }
      });
      if (bad_require_detected) {
        code = esprima.parse(unit.src, {
          loc: true
        });
        ast.traverse(code, [ast.isRequire], function(node) {
          var arg, modulename;
          node.loc.fpath = filepath;
          arg = node["arguments"][0];
          if (arg && arg.type === 'Literal') {
            modulename = arg.value;
            try {
              return resolver.sync(modulename, {
                extensions: ['.js', '.node'],
                basedir: path.dirname(filepath)
              });
            } catch (_error) {
              e = _error;
              return unit.warnings.push({
                node: node,
                reason: "resolve"
              });
            }
          } else {
            return unit.warnings.push({
              node: node,
              reason: "nonconst"
            });
          }
        });
      }
      return unit;
    }
  };

}).call(this);

/*
//@ sourceMappingURL=bna.map
*/
